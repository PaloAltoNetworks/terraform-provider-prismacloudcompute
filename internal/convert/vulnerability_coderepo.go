package convert

import (
	"github.com/PaloAltoNetworks/terraform-provider-prismacloudcompute/internal/api/policy"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func SchemaToVulnerabilityCoderepoRules(d *schema.ResourceData) ([]policy.VulnerabilityCoderepoRule, error) {
	parsedRules := make([]policy.VulnerabilityCoderepoRule, 0)
	if rules, ok := d.GetOk("rule"); ok {
		presentRules := rules.([]interface{})
		for _, val := range presentRules {
			presentRule := val.(map[string]interface{})
			parsedRule := policy.VulnerabilityCoderepoRule{}

			if presentRule["alert_threshold"].([]interface{})[0] != nil {
				presentAlertThreshold := presentRule["alert_threshold"].([]interface{})[0].(map[string]interface{})
				parsedRule.AlertThreshold = policy.VulnerabilityCoderepoThreshold{
					Disabled: presentAlertThreshold["disabled"].(bool),
					Value:    presentAlertThreshold["value"].(int),
				}
			} else {
				parsedRule.AlertThreshold = policy.VulnerabilityCoderepoThreshold{}
			}

			parsedRule.Collections = PolicySchemaToCollections(presentRule["collections"].([]interface{}))

			parsedRule.CreatePR = presentRule["create_pr"].(bool)

			presentCveRules := presentRule["cve_rule"].([]interface{})
			parsedCveRules := make([]policy.VulnerabilityCoderepoCveRule, 0, len(presentCveRules))
			for _, val := range presentCveRules {
				presentCveRule := val.(map[string]interface{})
				parsedCveRules = append(parsedCveRules, policy.VulnerabilityCoderepoCveRule{
					Description: presentCveRule["description"].(string),
					Effect:      presentCveRule["effect"].(string),
					Expiration:  schemaToVulnerabilityCoderepoExpiration(presentCveRule["expiration"].([]interface{})),
					Id:          presentCveRule["id"].(string),
				})
			}
			parsedRule.CveRules = parsedCveRules

			parsedRule.Disabled = presentRule["disabled"].(bool)
			parsedRule.Effect = presentRule["effect"].(string)
			parsedRule.Name = presentRule["name"].(string)
			parsedRule.Notes = presentRule["notes"].(string)
			parsedRule.OnlyFixed = presentRule["only_fixed"].(bool)

			presentTagRules := presentRule["tag_rule"].([]interface{})
			parsedTagRules := make([]policy.VulnerabilityCoderepoTagRule, 0, len(presentTagRules))
			for _, val := range presentTagRules {
				presentTagRule := val.(map[string]interface{})
				parsedTagRules = append(parsedTagRules, policy.VulnerabilityCoderepoTagRule{
					Description: presentTagRule["description"].(string),
					Effect:      presentTagRule["effect"].(string),
					Expiration:  schemaToVulnerabilityCoderepoExpiration(presentTagRule["expiration"].([]interface{})),
					Name:        presentTagRule["name"].(string),
				})
			}
			parsedRule.TagRules = parsedTagRules

			parsedRule.Verbose = presentRule["verbose"].(bool)

			parsedRules = append(parsedRules, parsedRule)
		}
	}
	return parsedRules, nil
}

func schemaToVulnerabilityCoderepoExpiration(in []interface{}) policy.VulnerabilityCoderepoExpiration {
	parsedExpiration := policy.VulnerabilityCoderepoExpiration{}
	if in[0] == nil {
		return parsedExpiration
	}
	presentExpiration := in[0].(map[string]interface{})
	parsedExpiration.Date = presentExpiration["date"].(string)
	parsedExpiration.Enabled = presentExpiration["enabled"].(bool)
	return parsedExpiration
}

func VulnerabilityCoderepoRulesToSchema(in []policy.VulnerabilityCoderepoRule) []interface{} {
	ans := make([]interface{}, 0, len(in))
	for _, val := range in {
		m := make(map[string]interface{})
		m["alert_threshold"] = vulnerabilityCoderepoAlertThresholdToSchema(val.AlertThreshold)
		m["collections"] = CollectionsToPolicySchema(val.Collections)
		m["create_pr"] = val.CreatePR
		m["cve_rule"] = vulnerabilityCoderepoCveRulesToSchema(val.CveRules)
		m["disabled"] = val.Disabled
		m["effect"] = val.Effect
		m["name"] = val.Name
		m["notes"] = val.Notes
		m["only_fixed"] = val.OnlyFixed
		m["tag_rule"] = vulnerabilityCoderepoTagRulesToSchema(val.TagRules)
		m["verbose"] = val.Verbose
		ans = append(ans, m)
	}
	return ans
}

func vulnerabilityCoderepoAlertThresholdToSchema(in policy.VulnerabilityCoderepoThreshold) []interface{} {
	ans := make([]interface{}, 0, 1)
	m := make(map[string]interface{})
	m["disabled"] = in.Disabled
	m["value"] = in.Value
	ans = append(ans, m)
	return ans
}

func vulnerabilityCoderepoBlockThresholdToSchema(in policy.VulnerabilityCoderepoThreshold) []interface{} {
	ans := make([]interface{}, 0, 1)
	m := make(map[string]interface{})
	m["enabled"] = in.Enabled
	m["value"] = in.Value
	ans = append(ans, m)
	return ans
}

func vulnerabilityCoderepoCveRulesToSchema(in []policy.VulnerabilityCoderepoCveRule) []interface{} {
	ans := make([]interface{}, 0, len(in))
	for _, val := range in {
		m := make(map[string]interface{})
		m["description"] = val.Description
		m["effect"] = val.Effect
		m["expiration"] = vulnerabilityCoderepoExpirationToSchema(val.Expiration)
		m["id"] = val.Id
		ans = append(ans, m)
	}
	return ans
}

func vulnerabilityCoderepoExpirationToSchema(in policy.VulnerabilityCoderepoExpiration) []interface{} {
	ans := make([]interface{}, 0, 1)
	m := make(map[string]interface{})
	m["date"] = in.Date
	m["enabled"] = in.Enabled
	ans = append(ans, m)
	return ans
}

func vulnerabilityCoderepoTagRulesToSchema(in []policy.VulnerabilityCoderepoTagRule) []interface{} {
	ans := make([]interface{}, 0, len(in))
	for _, val := range in {
		m := make(map[string]interface{})
		m["description"] = val.Description
		m["effect"] = val.Effect
		m["expiration"] = vulnerabilityCoderepoExpirationToSchema(val.Expiration)
		m["name"] = val.Name
		ans = append(ans, m)
	}
	return ans
}

func vulnerabilityCoderepoGraceDaysPolicyToSchema(in policy.VulnerabilityCoderepoGraceDaysPolicy) []interface{} {
	ans := make([]interface{}, 0, 1)
	m := make(map[string]interface{})
	m["low"] = in.Low
	m["medium"] = in.Medium
	m["high"] = in.High
	m["critical"] = in.Critical
	ans = append(ans, m)
	return ans
}
